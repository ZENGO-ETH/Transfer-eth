"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const utils_1 = require("./utils");
(0, config_1.subtask)(task_names_1.TASK_NODE_GET_PROVIDER).setAction(async (args, hre, runSuper) => {
    if (!hre.config.liveFork.enabled)
        return;
    const provider = await runSuper(args);
    // Unwrap the low level provider
    const hardhatNetworkProvider = await (0, utils_1.getHardhatNetworkProvider)(provider);
    // Get fork info from the low level provider
    let fork = await (0, utils_1.retrieveForkUrlAndBlock)(hardhatNetworkProvider);
    // Update fork if needed
    const remoteProvider = new ethers_1.ethers.providers.JsonRpcBatchProvider(fork.url);
    let liveForkBlockNumber;
    switch (hre.config.liveFork.forkBlockNumber) {
        case "latest":
            liveForkBlockNumber = await remoteProvider.getBlockNumber();
            break;
        case "auto":
            // to avoid using different fork block number always, we can use a nearest checkpoint block
            // and sync from there. so that cache is present.
            liveForkBlockNumber = await remoteProvider.getBlockNumber();
            liveForkBlockNumber = Math.max(liveForkBlockNumber - (liveForkBlockNumber % 5000), fork.block);
            break;
        default:
            liveForkBlockNumber = hre.config.liveFork.forkBlockNumber;
            break;
    }
    if (liveForkBlockNumber - fork.block > 500) {
        // If user specified some fork block number, its not practical to replay
        // all the txs so far since it'd involve a lot of rpc requests.
        // Hence, the intended way to use live fork is to fork from a recent block.
        // Forking from the current block number
        (0, utils_1.logger)(`Configured fork block is ${fork.block}. Changing it to ${liveForkBlockNumber}.`);
        await hardhatNetworkProvider.request({
            method: "hardhat_reset",
            params: [
                {
                    forking: {
                        jsonRpcUrl: fork.url,
                        blockNumber: liveForkBlockNumber,
                    },
                },
            ],
        });
    }
    return provider;
});
(0, config_1.subtask)(task_names_1.TASK_NODE_SERVER_CREATED).setAction(async (args, hre, runSuper) => {
    if (!hre.config.liveFork.enabled)
        return;
    // Start the tx replayer in parallel
    (0, utils_1.startTxReplayer)(args.provider, hre.config.liveFork.txMatcher, hre.config.liveFork.delay).catch(console.error);
});
//# sourceMappingURL=task-extensions.js.map