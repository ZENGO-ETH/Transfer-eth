{"version":3,"sources":["../src/index.ts"],"names":["leb","blake2b","uint8arrays","utils","base32","base32Function","DelegatedNamespace","Protocol","CoinType","getLeb128Length","input","index","byte","entries","Error","defaultCoinType","MAIN","coinTypes","Object","values","protocols","filter","p","payloadHashLength","blsPublicKeyBytes","maxSubaddressLen","maxInt64StringLength","checksumHashLength","ethAddressLength","addressHash","ingest","Address","constructor","bytes","coinType","length","_coinType","protocol","network","payload","slice","namespaceLength","DELEGATED","namespace","namespaceBytes","Number","unsigned","decode","subAddr","subAddrHex","toString","encode","equals","addr","bigintToArray","v","tmp","BigInt","fromString","getChecksum","validateChecksum","data","checksum","newAddress","protocolByte","concat","newIDAddress","id","ID","newActorAddress","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","newDelegatedAddress","namespaceByte","newDelegatedEthAddress","ethAddr","isAddress","EVM","arrayify","address","checkAddressString","prefix","subAddrBytes","checksumBytes","newFromString","validateAddressString","addressString","error","includes","join","raw","isNaN","splitIndex","indexOf","namespaceStr","subAddrCksmStr","subAddrCksmBytes","namespaceNumber","payloadCksm","idFromAddress","parseInt","delegatedFromEthAddress","TEST","ethAddressFromDelegated","delegated","getAddress","ethAddressFromID","idAddress","buffer","ArrayBuffer","dataview","DataView","setUint8","setBigUint64","Uint8Array"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport * as uint8arrays from 'uint8arrays'\nimport { utils } from 'ethers'\nimport { base32 as base32Function } from './base32'\nimport { DelegatedNamespace, Protocol } from './enums'\nimport { CoinType } from './coinType'\n\nexport * from './coinType'\nexport * from './enums'\n\nexport interface AddressData {\n  protocol: Protocol\n  payload: Uint8Array\n  bytes: Uint8Array\n  coinType: CoinType\n  namespace?: number\n}\n\nfunction getLeb128Length(input: Uint8Array): number {\n  for (const [index, byte] of input.entries()) if (byte < 128) return index + 1\n  throw new Error('Failed to get Leb128 length')\n}\n\nconst defaultCoinType = CoinType.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// Store valid CoinTypes / Protocols for runtime validation\nconst coinTypes = Object.values(CoinType)\nconst protocols = Object.values(Protocol).filter(p => typeof p === 'number')\n\n// Defines the hash length taken over addresses\n// using the Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\n// The length of a BLS public key\nconst blsPublicKeyBytes = 48\n\n// The maximum length of a delegated address's sub-address.\nconst maxSubaddressLen = 54\n\n// The maximum length of `int64` as a string.\nconst maxInt64StringLength = 19\n\n// The hash length used for calculating address checksums.\nconst checksumHashLength = 4\n\n// The length of an Ethereum address in bytes\nconst ethAddressLength = 20\n\nfunction addressHash(ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly bytes: Uint8Array\n  readonly _coinType: CoinType\n\n  constructor(bytes: Uint8Array, coinType: CoinType = defaultCoinType) {\n    if (!bytes || !bytes.length) throw new Error('Missing bytes in address')\n\n    this.bytes = bytes\n    this._coinType = coinType\n\n    if (!(this.protocol() in Protocol)) {\n      throw new Error(`Invalid protocol ${this.protocol()}`)\n    }\n  }\n\n  network(): CoinType {\n    return this._coinType\n  }\n\n  coinType(): CoinType {\n    return this._coinType\n  }\n\n  protocol(): Protocol {\n    return this.bytes[0]\n  }\n\n  payload(): Uint8Array {\n    return this.bytes.slice(1)\n  }\n\n  get namespaceLength(): number {\n    if (this.protocol() !== Protocol.DELEGATED)\n      throw new Error('Can only get namespace length for delegated addresses')\n    return getLeb128Length(this.payload())\n  }\n\n  get namespace(): number {\n    if (this.protocol() !== Protocol.DELEGATED)\n      throw new Error('Can only get namespace for delegated addresses')\n    const namespaceBytes = this.payload().slice(0, this.namespaceLength)\n    return Number(leb.unsigned.decode(namespaceBytes))\n  }\n\n  get subAddr(): Uint8Array {\n    if (this.protocol() !== Protocol.DELEGATED)\n      throw new Error('Can only get subaddress for delegated addresses')\n    return this.bytes.slice(this.namespaceLength + 1)\n  }\n\n  get subAddrHex(): string {\n    return uint8arrays.toString(this.subAddr, 'hex')\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"coinType\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default coinType prefix \"f\" (mainnet).\n   */\n  toString(): string {\n    return encode(this._coinType, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"bytes\" property matches byte for byte.\n   */\n  equals(addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.bytes, addr.bytes)\n  }\n}\n\nexport function bigintToArray(v: string | bigint | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, checksumHashLength)\n}\n\nexport function validateChecksum(\n  data: string | Uint8Array,\n  checksum: Uint8Array\n): boolean {\n  return uint8arrays.equals(getChecksum(data), checksum)\n}\n\nexport function newAddress(\n  protocol: Protocol,\n  payload: Uint8Array,\n  coinType?: CoinType\n): Address {\n  const protocolByte = leb.unsigned.encode(protocol)\n  return new Address(uint8arrays.concat([protocolByte, payload]), coinType)\n}\n\nexport function newIDAddress(\n  id: number | string,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), coinType)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress(\n  data: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data), coinType)\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address(\n  pubkey: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey), coinType)\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress(\n  pubkey: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.BLS, pubkey, coinType)\n}\n\n/**\n * newDelegatedAddress returns an address using the Delegated protocol.\n */\nexport function newDelegatedAddress(\n  namespace: number,\n  subAddr: Uint8Array,\n  coinType?: CoinType\n): Address {\n  if (subAddr.length > maxSubaddressLen)\n    throw new Error('Subaddress address length')\n\n  const namespaceByte = leb.unsigned.encode(namespace)\n  return newAddress(\n    Protocol.DELEGATED,\n    uint8arrays.concat([namespaceByte, subAddr]),\n    coinType\n  )\n}\n\n/**\n * newDelegatedEthAddress returns an address for eth using the Delegated protocol.\n */\nexport function newDelegatedEthAddress(\n  ethAddr: string,\n  coinType?: CoinType\n): Address {\n  if (!utils.isAddress(ethAddr)) throw new Error('Invalid Ethereum address')\n\n  return newDelegatedAddress(\n    DelegatedNamespace.EVM,\n    utils.arrayify(ethAddr),\n    coinType\n  )\n}\n\nexport function decode(address: string): Address {\n  const { protocol, payload, coinType } = checkAddressString(address)\n  return newAddress(protocol, payload, coinType)\n}\n\nexport function encode(coinType: string, address: Address): string {\n  if (!address || !address.bytes) throw Error('Invalid address')\n\n  const protocol = address.protocol()\n  const payload = address.payload()\n  const prefix = `${coinType}${protocol}`\n\n  switch (protocol) {\n    case Protocol.ID: {\n      return `${prefix}${leb.unsigned.decode(payload)}`\n    }\n    case Protocol.DELEGATED: {\n      const namespace = address.namespace\n      const subAddrBytes = address.subAddr\n      const protocolByte = leb.unsigned.encode(protocol)\n      const namespaceByte = leb.unsigned.encode(namespace)\n      const checksumBytes = getChecksum(\n        uint8arrays.concat([protocolByte, namespaceByte, subAddrBytes])\n      )\n\n      const bytes = uint8arrays.concat([subAddrBytes, checksumBytes])\n      return `${prefix}${namespace}f${base32.encode(bytes)}`\n    }\n    default: {\n      const checksum = getChecksum(address.bytes)\n      const bytes = uint8arrays.concat([payload, checksum])\n      return `${prefix}${base32.encode(bytes)}`\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string): AddressData {\n  if (typeof address !== 'string' || address.length < 3)\n    throw Error('Address should be a string of at least 3 characters')\n\n  const coinType = address[0] as CoinType\n  if (!coinTypes.includes(coinType))\n    throw Error(`Address cointype should be one of: ${coinTypes.join(', ')}`)\n\n  const protocol = Number(address[1]) as Protocol\n  if (!protocols.includes(protocol))\n    throw Error(`Address protocol should be one of: ${protocols.join(', ')}`)\n\n  const protocolByte = leb.unsigned.encode(protocol)\n  const raw = address.slice(2)\n\n  switch (protocol) {\n    case Protocol.ID: {\n      if (raw.length > maxInt64StringLength)\n        throw Error('Invalid ID address length')\n      if (isNaN(Number(raw))) throw Error('Invalid ID address')\n      const payload = leb.unsigned.encode(raw)\n      const bytes = uint8arrays.concat([protocolByte, payload])\n      return { protocol, payload, bytes, coinType }\n    }\n\n    case Protocol.DELEGATED: {\n      const splitIndex = raw.indexOf('f')\n      if (splitIndex === -1) throw new Error('Invalid delegated address')\n\n      const namespaceStr = raw.slice(0, splitIndex)\n      if (namespaceStr.length > maxInt64StringLength)\n        throw new Error('Invalid delegated address namespace')\n\n      const subAddrCksmStr = raw.slice(splitIndex + 1)\n      const subAddrCksmBytes = base32.decode(subAddrCksmStr)\n      if (subAddrCksmBytes.length < checksumHashLength)\n        throw Error('Invalid delegated address length')\n\n      const subAddrBytes = subAddrCksmBytes.slice(0, -checksumHashLength)\n      const checksumBytes = subAddrCksmBytes.slice(subAddrBytes.length)\n      if (subAddrBytes.length > maxSubaddressLen)\n        throw Error('Invalid delegated address length')\n\n      const namespaceNumber = Number(namespaceStr)\n      const namespaceByte = leb.unsigned.encode(namespaceNumber)\n      const payload = uint8arrays.concat([namespaceByte, subAddrBytes])\n      const bytes = uint8arrays.concat([protocolByte, payload])\n\n      if (!validateChecksum(bytes, checksumBytes))\n        throw Error('Invalid delegated address checksum')\n\n      return { protocol, payload, bytes, coinType, namespace: namespaceNumber }\n    }\n\n    case Protocol.SECP256K1:\n    case Protocol.ACTOR:\n    case Protocol.BLS: {\n      const payloadCksm = base32.decode(raw)\n      if (payloadCksm.length < checksumHashLength)\n        throw Error('Invalid address length')\n\n      const payload = payloadCksm.slice(0, -checksumHashLength)\n      const checksum = payloadCksm.slice(payload.length)\n\n      if (protocol === Protocol.SECP256K1 || protocol === Protocol.ACTOR)\n        if (payload.length !== payloadHashLength)\n          throw Error('Invalid address length')\n\n      if (protocol === Protocol.BLS)\n        if (payload.length !== blsPublicKeyBytes)\n          throw Error('Invalid address length')\n\n      const bytes = uint8arrays.concat([protocolByte, payload])\n      if (!validateChecksum(bytes, checksum))\n        throw Error('Invalid address checksum')\n\n      return { protocol, payload, bytes, coinType }\n    }\n\n    default:\n      throw Error(`Invalid address protocall: ${protocol}`)\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress(address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\n/**\n * delegatedFromEthAddress derives the f410 address from an ethereum hex address\n */\n\nexport function delegatedFromEthAddress(\n  ethAddr: string,\n  coinType: CoinType = CoinType.TEST\n): string {\n  return newDelegatedEthAddress(ethAddr, coinType).toString()\n}\n\n/**\n * ethAddressFromDelegated derives the ethereum address from an f410 address\n */\n\nexport function ethAddressFromDelegated(delegated: string): string {\n  return utils.getAddress(`0x${decode(delegated).subAddrHex}`)\n}\n\n/**\n * ethAddressFromID derives the ethereum address from an f0 address\n */\n\nexport function ethAddressFromID(idAddress: string): string {\n  const address = decode(idAddress)\n  const id = idFromAddress(address)\n  const buffer = new ArrayBuffer(ethAddressLength)\n  const dataview = new DataView(buffer)\n  dataview.setUint8(0, 255)\n  dataview.setBigUint64(12, BigInt(id), false)\n  return `0x${uint8arrays.toString(new Uint8Array(buffer), 'hex')}`\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  delegatedFromEthAddress,\n  ethAddressFromDelegated,\n  CoinType,\n  Protocol\n}\n"],"file":"index.js"}