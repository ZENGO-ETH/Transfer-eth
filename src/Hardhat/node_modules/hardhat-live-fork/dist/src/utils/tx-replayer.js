"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTxReplayer = void 0;
const ethers_1 = require("ethers");
const hardhat_helpers_1 = require("./hardhat-helpers");
const hardhat_network_provider_1 = require("./hardhat-network-provider");
const logger_1 = require("./logger");
const retrive_fork_url_and_block_1 = require("./retrive-fork-url-and-block");
async function startTxReplayer(wrappedProvider, matcher, delay) {
    const provider = await (0, hardhat_network_provider_1.getHardhatNetworkProvider)(wrappedProvider);
    const fork = await (0, retrive_fork_url_and_block_1.retrieveForkUrlAndBlock)(provider);
    const remoteProvider = new ethers_1.ethers.providers.JsonRpcBatchProvider(fork.url);
    const impersonatedAddresses = new Map();
    let syncedBlockNumber = fork.block;
    while (1) {
        await replayUptoLatest();
        // cool down for a bit
        await new Promise((resolve) => setTimeout(resolve, delay));
    }
    async function replayUptoLatest() {
        // get latest block number
        const target = await remoteProvider.getBlockNumber();
        let batchTarget;
        do {
            // only fetch 50 blocks at a time
            // TODO make it by chain id
            batchTarget = Math.min(target, syncedBlockNumber + 50);
            if (batchTarget !== syncedBlockNumber) {
                let blocks = [];
                if (batchTarget !== syncedBlockNumber + 1) {
                    // make a batch query to fetch all the unreplayed blocks so far
                    (0, logger_1.logger)(`Receiving ${batchTarget - syncedBlockNumber} blocks: from ${syncedBlockNumber + 1} to ${batchTarget} (latest: ${target})`);
                    blocks = await Promise.all(new Array(batchTarget - syncedBlockNumber)
                        .fill(null)
                        .map((_, i) => {
                        const number = syncedBlockNumber + 1 + i;
                        return remoteProvider.getBlockWithTransactions(number);
                    }));
                }
                else {
                    // fetch the one replayed block
                    (0, logger_1.logger)(`Receiving 1 block: ${batchTarget}`);
                    blocks = [await remoteProvider.getBlockWithTransactions(batchTarget)];
                }
                // replay matched successful txs from each block
                await replayBlocks(blocks);
                // start after target
                syncedBlockNumber = batchTarget;
            }
        } while (batchTarget !== target);
    }
    async function replayBlocks(blocks) {
        const txsMatched = [];
        let totalTxs = 0;
        // ignore unmatched txs
        for (const block of blocks) {
            for (const tx of block.transactions) {
                if (!matcher || matcher(tx)) {
                    txsMatched.push(tx);
                }
            }
            totalTxs += block.transactions.length;
        }
        // ignore reverted / out of gas txs
        const rcs = await Promise.all(txsMatched.map((tx) => remoteProvider.getTransactionReceipt(tx.hash)));
        const txsToReplay = txsMatched.filter((_, i) => !!rcs[i].status);
        (0, logger_1.logger)(`Matched ${txsToReplay.length} out of ${totalTxs} txs`);
        for (const tx of txsToReplay) {
            // impersonate the address if not already
            if (!impersonatedAddresses.get(tx.from)) {
                await (0, hardhat_helpers_1.impersonateAccount)(provider, tx.from);
            }
            impersonatedAddresses.set(tx.from, true);
            // replay the tx
            const timeStart = Date.now();
            let i = 2;
            while (i--) {
                try {
                    await (0, hardhat_helpers_1.sendTx)(provider, tx);
                }
                catch (e) {
                    const errorMessage = e.message;
                    if (errorMessage.includes("doesn't have enough funds to send tx")) {
                        // fund tx.from
                        await (0, hardhat_helpers_1.fundBalance)(provider, tx.from);
                        continue; // and then try once more
                    }
                    else {
                        console.error(e);
                    }
                }
                break;
            }
            const timeEnd = Date.now();
            (0, logger_1.logger)(`Successfully replayed tx ${tx.hash} (took: ${timeEnd - timeStart}ms)`);
        }
    }
}
exports.startTxReplayer = startTxReplayer;
//# sourceMappingURL=tx-replayer.js.map